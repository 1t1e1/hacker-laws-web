<!doctype html><html class=no-js lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#1b1b1b"><title>Laws | My Hugo Site</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><link rel=stylesheet href=/hacker-laws-web/css/bundle.css><link rel=icon href=/hacker-laws-web/icons/16.png sizes=16x16 type=image/png><link rel=icon href=/hacker-laws-web/icons/32.png sizes=32x32 type=image/png><link rel=alternate type=application/rss+xml href=/hacker-laws-web/law/index.xml title="My Hugo Site"></head><body><header class=header><a class=logo href=/hacker-laws-web>My Hugo Site</a></header><div class=primary><main class=main><div class="page block"><h1 class=page__title>Laws</h1></div><div class=cards><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/hyrums-law-the-law-of-implicit-interfaces/>Hyrum's Law (The Law of Implicit Interfaces)</a></h1><div class=post__content>Hyrum&rsquo;s Law Online
With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviours of your system will be depended on by somebody.
(Hyrum Wright)
Hyrum&rsquo;s Law states that when you have a large enough number of consumers of an API, all behaviours of the API (even those not defined as part of a public contract) will eventually come to be depended on by someone.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/metcalfes-law/>Metcalfe's Law</a></h1><div class=post__content>Metcalfe&rsquo;s Law on Wikipedia
In network theory, the value of a system grows as approximately the square of the number of users of the system.
This law is based on the number of possible pairwise connections within a system and is closely related to Reed&rsquo;s Law. Odlyzko and others have argued that both Reed&rsquo;s Law and Metcalfe&rsquo;s Law overstate the value of the system by not accounting for the limits of human cognition on network effects; see Dunbar&rsquo;s Number.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/moores-law/>Moore's Law</a></h1><div class=post__content>Moore&rsquo;s Law on Wikipedia
The number of transistors in an integrated circuit doubles approximately every two years.
Often used to illustrate the sheer speed at which semiconductor and chip technology has improved, Moore&rsquo;s prediction has proven to be highly accurate over from the 1970s to the late 2000s. In more recent years, the trend has changed slightly, partly due to physical limitations on the degree to which components can be miniaturised.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/murphys-law-sods-law/>Murphy's Law / Sod's Law</a></h1><div class=post__content>Murphy&rsquo;s Law on Wikipedia
Anything that can go wrong will go wrong.
Related to Edward A. Murphy, Jr Murphy&rsquo;s Law states that if a thing can go wrong, it will go wrong.
This is a common adage among developers. Sometimes the unexpected happens when developing, testing or even in production. This can also be related to the (more common in British English) Sod&rsquo;s Law:
If something can go wrong, it will, at the worst possible time.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/occams-razor/>Occam's Razor</a></h1><div class=post__content>Occam&rsquo;s Razor on Wikipedia
Entities should not be multiplied without necessity.
William of Ockham
Occam&rsquo;s razor says that among several possible solutions, the most likely solution is the one with the least number of concepts and assumptions. This solution is the simplest and solves only the given problem, without introducing accidental complexity and possible negative consequences.
See also:
YAGNI No Silver Bullet: Accidental Complexity and Essential Complexity Example:</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/parkinsons-law/>Parkinson's Law</a></h1><div class=post__content>Parkinson&rsquo;s Law on Wikipedia
Work expands so as to fill the time available for its completion.
In its original context, this Law was based on studies of bureaucracies. It may be pessimistically applied to software development initiatives, the theory being that teams will be inefficient until deadlines near, then rush to complete work by the deadline, thus making the actual deadline somewhat arbitrary.
If this law were combined with Hofstadter&rsquo;s Law, an even more pessimistic viewpoint is reached - work will expand to fill the time available for its completion and still take longer than expected.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/premature-optimization-effect/>Premature Optimization Effect</a></h1><div class=post__content>Premature Optimization on WikiWikiWeb
Premature optimization is the root of all evil.
(Donald Knuth)
In Donald Knuth&rsquo;s paper Structured Programming With Go To Statements, he wrote: &ldquo;Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/putts-law/>Putt's Law</a></h1><div class=post__content>Putt&rsquo;s Law on Wikipedia
Technology is dominated by two types of people, those who understand what they do not manage and those who manage what they do not understand.
Putt&rsquo;s Law is often followed by Putt&rsquo;s Corollary:
Every technical hierarchy, in time, develops a competence inversion.
These statements suggest that due to various selection criteria and trends in how groups organise, there will be a number of skilled people at working levels of a technical organisations, and a number of people in managerial roles who are not aware of the complexities and challenges of the work they are managing.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/reeds-law/>Reed's Law</a></h1><div class=post__content>Reed&rsquo;s Law on Wikipedia
The utility of large networks, particularly social networks, scales exponentially with the size of the network.
This law is based on graph theory, where the utility scales as the number of possible sub-groups, which is faster than the number of participants or the number of possible pairwise connections. Odlyzko and others have argued that Reed&rsquo;s Law overstates the utility of the system by not accounting for the limits of human cognition on network effects; see Dunbar&rsquo;s Number.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/solid/>SOLID</a></h1><div class=post__content>This is an acronym, which refers to:
S: The Single Responsibility Principle O: The Open/Closed Principle L: The Liskov Substitution Principle I: The Interface Segregation Principle D: The Dependency Inversion Principle These are key principles in Object-Oriented Programming. Design principles such as these should be able to aid developers build more maintainable systems.</div></article></div></div></main><div class="pagination block"><a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/>1</a>
<span class="pagination__item pagination__item--active" data-total=5>2</span>
<a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/page/3/>3</a>
<span class="pagination__item pagination__item--gap">&mldr;</span>
<a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/page/5/>5</a></div></div><footer class=footer><div class=footer__copyright>Â© 2020 My Hugo Site. <span class=footer__copyright-credits>Powered by <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/vimux/binario rel="nofollow noopener" target=_blank>Binario</a> theme.</span></div></footer></body></html>