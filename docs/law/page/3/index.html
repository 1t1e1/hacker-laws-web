<!doctype html><html class=no-js lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#1b1b1b"><title>Laws | My Hugo Site</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><link rel=stylesheet href=/hacker-laws-web/css/bundle.css><link rel=icon href=/hacker-laws-web/icons/16.png sizes=16x16 type=image/png><link rel=icon href=/hacker-laws-web/icons/32.png sizes=32x32 type=image/png><link rel=alternate type=application/rss+xml href=/hacker-laws-web/law/index.xml title="My Hugo Site"></head><body><header class=header><a class=logo href=/hacker-laws-web>My Hugo Site</a></header><div class=primary><main class=main><div class="page block"><h1 class=page__title>Laws</h1></div><div class=cards><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-broken-windows-theory/>The Broken Windows Theory</a></h1><div class=post__content>The Broken Windows Theory on Wikipedia
The Broken Windows Theory suggests that visible signs of crime (or lack of care of an environment) lead to further and more serious crimes (or further deterioration of the environment).
This theory has been applied to software development, suggesting that poor quality code (or Technical Debt) can lead to a perception that efforts to improve quality may be ignored or undervalued, thus leading to further poor quality code.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-dependency-inversion-principle/>The Dependency Inversion Principle</a></h1><div class=post__content>The Dependency Inversion Principle on Wikipedia
High-level modules should not be dependent on low-level implementations.
The fifth of the &lsquo;SOLID&rsquo; principles. This principle states that higher level orchestrating components should not have to know the details of their dependencies.
As an example, imagine we have a program which read metadata from a website. We would assume that the main component would have to know about a component to download the webpage content, then a component which can read the metadata.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-dilbert-principle/>The Dilbert Principle</a></h1><div class=post__content>The Dilbert Principle on Wikipedia
Companies tend to systematically promote incompetent employees to management to get them out of the workflow.
Scott Adams
A management concept developed by Scott Adams (creator of the Dilbert comic strip), the Dilbert Principle is inspired by The Peter Principle. Under the Dilbert Principle, employees who were never competent are promoted to management in order to limit the damage they can do. Adams first explained the principle in a 1995 Wall Street Journal article, and expanded upon it in his 1996 business book, The Dilbert Principle.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-dry-principle/>The DRY Principle</a></h1><div class=post__content>The DRY Principle on Wikipedia
Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
DRY is an acronym for Don&rsquo;t Repeat Yourself. This principle aims to help developers reducing the repetition of code and keep the information in a single place and was cited in 1999 by Andrew Hunt and Dave Thomas in the book The Pragmatic Developer
The opposite of DRY would be WET (Write Everything Twice or We Enjoy Typing).</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-fallacies-of-distributed-computing/>The Fallacies of Distributed Computing</a></h1><div class=post__content>The Fallacies of Distributed Computing on Wikipedia
Also known as Fallacies of Networked Computing, the Fallacies are a list of conjectures (or beliefs) about distributed computing, which can lead to failures in software development. The assumptions are:
The network is reliable Latency is zero Bandwidth is infinite The network is secure Topology doesn&rsquo;t change There is one administrator Transport cost is zero The network is homogeneous The first four items were listed by Bill Joy and Tom Lyon around 1991 and first classified by James Gosling as the &ldquo;Fallacies of Networked Computing&rdquo;.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-hype-cycle-amaras-law/>The Hype Cycle & Amara's Law</a></h1><div class=post__content>The Hype Cycle on Wikipedia
We tend to overestimate the effect of a technology in the short run and underestimate the effect in the long run.
(Roy Amara)
The Hype Cycle is a visual representation of the excitement and development of technology over time, originally produced by Gartner. It is best shown with a visual:
(Image Reference: By Jeremykemp at English Wikipedia, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=10547051)
In short, this cycle suggests that there is typically a burst of excitement around new technology and its potential impact.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-interface-segregation-principle/>The Interface Segregation Principle</a></h1><div class=post__content>The Interface Segregation Principle on Wikipedia
No client should be forced to depend on methods it does not use.
The fourth of the &lsquo;SOLID&rsquo; principles. This principle states that consumers of a component should not depend on functions of that component which it doesn&rsquo;t actually use.
As an example, imagine we have a method which reads an XML document from a structure which represents a file. It only needs to read bytes, move forwards or move backwards in the file.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-kiss-principle/>The KISS principle</a></h1><div class=post__content>KISS on Wikipedia
Keep it simple, stupid
The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. Originating in the U.S. Navy in 1960, the phrase has been associated with aircraft engineer Kelly Johnson.
The principle is best exemplified by the story of Johnson handing a team of design engineers a handful of tools, with the challenge that the jet aircraft they were designing must be repairable by an average mechanic in the field under combat conditions with only these tools.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-law-of-conservation-of-complexity-teslers-law/>The Law of Conservation of Complexity (Tesler's Law)</a></h1><div class=post__content>The Law of Conservation of Complexity on Wikipedia
This law states that there is a certain amount of complexity in a system which cannot be reduced.
Some complexity in a system is &lsquo;inadvertent&rsquo;. It is a consequence of poor structure, mistakes, or just bad modeling of a problem to solve. Inadvertent complexity can be reduced (or eliminated). However, some complexity is &lsquo;intrinsic&rsquo; as a consequence of the complexity inherent in the problem being solved.</div></article></div><div class="card card--2col"><article class="post card__box block"><h1 class="post__title title-excerpt"><a class=post__title-link href=/hacker-laws-web/law/the-law-of-leaky-abstractions/>The Law of Leaky Abstractions</a></h1><div class=post__content>The Law of Leaky Abstractions on Joel on Software
All non-trivial abstractions, to some degree, are leaky.
(Joel Spolsky)
This law states that abstractions, which are generally used in computing to simplify working with complicated systems, will in certain situations &lsquo;leak&rsquo; elements of the underlying system, this making the abstraction behave in an unexpected way.
An example might be loading a file and reading its contents. The file system APIs are an abstraction of the lower level kernel systems, which are themselves an abstraction over the physical processes relating to changing data on a magnetic platter (or flash memory for an SSD).</div></article></div></div></main><div class="pagination block"><a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/>1</a>
<a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/page/2/>2</a>
<span class="pagination__item pagination__item--active" data-total=5>3</span>
<a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/page/4/>4</a>
<a class="pagination__item pagination__item--desktop" href=/hacker-laws-web/law/page/5/>5</a></div></div><footer class=footer><div class=footer__copyright>Â© 2020 My Hugo Site. <span class=footer__copyright-credits>Powered by <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/vimux/binario rel="nofollow noopener" target=_blank>Binario</a> theme.</span></div></footer></body></html>