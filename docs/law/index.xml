<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Laws on My Hugo Site</title><link>https://1t1e1.github.io/hacker-laws-web/law/</link><description>Recent content in Laws on My Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://1t1e1.github.io/hacker-laws-web/law/index.xml" rel="self" type="application/rss+xml"/><item><title>Amdahl's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/amdahls-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/amdahls-law/</guid><description>Amdahl&amp;rsquo;s Law on Wikipedia
Amdahl&amp;rsquo;s Law is a formula which shows the potential speedup of a computational task which can be achieved by increasing the resources of a system. Normally used in parallel computing, it can predict the actual benefit of increasing the number of processors, which is limited by the parallelisability of the program.
Best illustrated with an example. If a program is made up of two parts, part A, which must be executed by a single processor, and part B, which can be parallelised, then we see that adding multiple processors to the system executing the program can only have a limited benefit.</description></item><item><title>Brooks' Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/brooks-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/brooks-law/</guid><description>Brooks&amp;rsquo; Law on Wikipedia
Adding human resources to a late software development project makes it later.
This law suggests that in many cases, attempting to accelerate the delivery of a project which is already late, by adding more people, will make the delivery even later. Brooks is clear that this is an over-simplification, however, the general reasoning is that given the ramp up time of new resources and the communication overheads, in the immediate short-term velocity decreases.</description></item><item><title>Conway's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/conways-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/conways-law/</guid><description>Conway&amp;rsquo;s Law on Wikipedia
This law suggests that the technical boundaries of a system will reflect the structure of the organisation. It is commonly referred to when looking at organisation improvements, Conway&amp;rsquo;s Law suggests that if an organisation is structured into many small, disconnected units, the software it produces will be. If an organisation is built more around &amp;lsquo;verticals&amp;rsquo; which are orientated around features or services, the software systems will also reflect this.</description></item><item><title>Cunningham's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/cunninghams-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/cunninghams-law/</guid><description>Cunningham&amp;rsquo;s Law on Wikipedia
The best way to get the right answer on the Internet is not to ask a question, it&amp;rsquo;s to post the wrong answer.
According to Steven McGeady, Ward Cunningham advised him in the early 1980s: &amp;ldquo;The best way to get the right answer on the Internet is not to ask a question, it&amp;rsquo;s to post the wrong answer.&amp;rdquo; McGeady dubbed this Cunningham&amp;rsquo;s law, though Cunningham denies ownership calling it a &amp;ldquo;misquote.</description></item><item><title>Dunbar's Number</title><link>https://1t1e1.github.io/hacker-laws-web/law/dunbars-number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/dunbars-number/</guid><description>Dunbar&amp;rsquo;s Number on Wikipedia
&amp;ldquo;Dunbar&amp;rsquo;s number is a suggested cognitive limit to the number of people with whom one can maintain stable social relationships— relationships in which an individual knows who each person is and how each person relates to every other person.&amp;rdquo; There is some disagreement to the exact number. &amp;ldquo;&amp;hellip; [Dunbar] proposed that humans can comfortably maintain only 150 stable relationships.&amp;rdquo; He put the number into a more social context, &amp;ldquo;the number of people you would not feel embarrassed about joining uninvited for a drink if you happened to bump into them in a bar.</description></item><item><title>Gall's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/galls-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/galls-law/</guid><description>Gall&amp;rsquo;s Law on Wikipedia
A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.
(John Gall)
Gall&amp;rsquo;s Law implies that attempts to design highly complex systems are likely to fail. Highly complex systems are rarely built in one go, but evolve instead from more simple systems.</description></item><item><title>Goodhart's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/goodharts-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/goodharts-law/</guid><description>The Goodhart&amp;rsquo;s Law on Wikipedia
Any observed statistical regularity will tend to collapse once pressure is placed upon it for control purposes.
Charles Goodhart
Also commonly referenced as:
When a measure becomes a target, it ceases to be a good measure.
Marilyn Strathern
The law states that the measure-driven optimizations could lead to devaluation of the measurement outcome itself. Overly selective set of measures (KPIs) blindly applied to a process results in distorted effect.</description></item><item><title>Hanlon's Razor</title><link>https://1t1e1.github.io/hacker-laws-web/law/hanlons-razor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/hanlons-razor/</guid><description>Hanlon&amp;rsquo;s Razor on Wikipedia
Never attribute to malice that which is adequately explained by stupidity.
Robert J. Hanlon
This principle suggests that actions resulting in a negative outcome were not a result of ill will. Instead the negative outcome is more likely attributed to those actions and/or the impact being not fully understood.</description></item><item><title>Hofstadter's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/hofstadters-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/hofstadters-law/</guid><description>Hofstadter&amp;rsquo;s Law on Wikipedia
It always takes longer than you expect, even when you take into account Hofstadter&amp;rsquo;s Law.
(Douglas Hofstadter)
You might hear this law referred to when looking at estimates for how long something will take. It seems a truism in software development that we tend to not be very good at accurately estimating how long something will take to deliver.
This is from the book &amp;lsquo;Gödel, Escher, Bach: An Eternal Golden Braid'.</description></item><item><title>Hutber's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/hutbers-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/hutbers-law/</guid><description>Hutber&amp;rsquo;s Law on Wikipedia
Improvement means deterioration.
(Patrick Hutber)
This law suggests that improvements to a system will lead to deterioration in other parts, or it will hide other deterioration, leading overall to a degradation from the current state of the system.
For example, a decrease in response latency for a particular end-point could cause increased throughput and capacity issues further along in a request flow, affecting an entirely different sub-system.</description></item><item><title>Hyrum's Law (The Law of Implicit Interfaces)</title><link>https://1t1e1.github.io/hacker-laws-web/law/hyrums-law-the-law-of-implicit-interfaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/hyrums-law-the-law-of-implicit-interfaces/</guid><description>Hyrum&amp;rsquo;s Law Online
With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviours of your system will be depended on by somebody.
(Hyrum Wright)
Hyrum&amp;rsquo;s Law states that when you have a large enough number of consumers of an API, all behaviours of the API (even those not defined as part of a public contract) will eventually come to be depended on by someone.</description></item><item><title>Metcalfe's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/metcalfes-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/metcalfes-law/</guid><description>Metcalfe&amp;rsquo;s Law on Wikipedia
In network theory, the value of a system grows as approximately the square of the number of users of the system.
This law is based on the number of possible pairwise connections within a system and is closely related to Reed&amp;rsquo;s Law. Odlyzko and others have argued that both Reed&amp;rsquo;s Law and Metcalfe&amp;rsquo;s Law overstate the value of the system by not accounting for the limits of human cognition on network effects; see Dunbar&amp;rsquo;s Number.</description></item><item><title>Moore's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/moores-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/moores-law/</guid><description>Moore&amp;rsquo;s Law on Wikipedia
The number of transistors in an integrated circuit doubles approximately every two years.
Often used to illustrate the sheer speed at which semiconductor and chip technology has improved, Moore&amp;rsquo;s prediction has proven to be highly accurate over from the 1970s to the late 2000s. In more recent years, the trend has changed slightly, partly due to physical limitations on the degree to which components can be miniaturised.</description></item><item><title>Murphy's Law / Sod's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/murphys-law-sods-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/murphys-law-sods-law/</guid><description>Murphy&amp;rsquo;s Law on Wikipedia
Anything that can go wrong will go wrong.
Related to Edward A. Murphy, Jr Murphy&amp;rsquo;s Law states that if a thing can go wrong, it will go wrong.
This is a common adage among developers. Sometimes the unexpected happens when developing, testing or even in production. This can also be related to the (more common in British English) Sod&amp;rsquo;s Law:
If something can go wrong, it will, at the worst possible time.</description></item><item><title>Occam's Razor</title><link>https://1t1e1.github.io/hacker-laws-web/law/occams-razor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/occams-razor/</guid><description>Occam&amp;rsquo;s Razor on Wikipedia
Entities should not be multiplied without necessity.
William of Ockham
Occam&amp;rsquo;s razor says that among several possible solutions, the most likely solution is the one with the least number of concepts and assumptions. This solution is the simplest and solves only the given problem, without introducing accidental complexity and possible negative consequences.
See also:
YAGNI No Silver Bullet: Accidental Complexity and Essential Complexity Example:</description></item><item><title>Parkinson's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/parkinsons-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/parkinsons-law/</guid><description>Parkinson&amp;rsquo;s Law on Wikipedia
Work expands so as to fill the time available for its completion.
In its original context, this Law was based on studies of bureaucracies. It may be pessimistically applied to software development initiatives, the theory being that teams will be inefficient until deadlines near, then rush to complete work by the deadline, thus making the actual deadline somewhat arbitrary.
If this law were combined with Hofstadter&amp;rsquo;s Law, an even more pessimistic viewpoint is reached - work will expand to fill the time available for its completion and still take longer than expected.</description></item><item><title>Premature Optimization Effect</title><link>https://1t1e1.github.io/hacker-laws-web/law/premature-optimization-effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/premature-optimization-effect/</guid><description>Premature Optimization on WikiWikiWeb
Premature optimization is the root of all evil.
(Donald Knuth)
In Donald Knuth&amp;rsquo;s paper Structured Programming With Go To Statements, he wrote: &amp;ldquo;Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.</description></item><item><title>Putt's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/putts-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/putts-law/</guid><description>Putt&amp;rsquo;s Law on Wikipedia
Technology is dominated by two types of people, those who understand what they do not manage and those who manage what they do not understand.
Putt&amp;rsquo;s Law is often followed by Putt&amp;rsquo;s Corollary:
Every technical hierarchy, in time, develops a competence inversion.
These statements suggest that due to various selection criteria and trends in how groups organise, there will be a number of skilled people at working levels of a technical organisations, and a number of people in managerial roles who are not aware of the complexities and challenges of the work they are managing.</description></item><item><title>Reed's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/reeds-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/reeds-law/</guid><description>Reed&amp;rsquo;s Law on Wikipedia
The utility of large networks, particularly social networks, scales exponentially with the size of the network.
This law is based on graph theory, where the utility scales as the number of possible sub-groups, which is faster than the number of participants or the number of possible pairwise connections. Odlyzko and others have argued that Reed&amp;rsquo;s Law overstates the utility of the system by not accounting for the limits of human cognition on network effects; see Dunbar&amp;rsquo;s Number.</description></item><item><title>SOLID</title><link>https://1t1e1.github.io/hacker-laws-web/law/solid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/solid/</guid><description>This is an acronym, which refers to:
S: The Single Responsibility Principle O: The Open/Closed Principle L: The Liskov Substitution Principle I: The Interface Segregation Principle D: The Dependency Inversion Principle These are key principles in Object-Oriented Programming. Design principles such as these should be able to aid developers build more maintainable systems.</description></item><item><title>The Broken Windows Theory</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-broken-windows-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-broken-windows-theory/</guid><description>The Broken Windows Theory on Wikipedia
The Broken Windows Theory suggests that visible signs of crime (or lack of care of an environment) lead to further and more serious crimes (or further deterioration of the environment).
This theory has been applied to software development, suggesting that poor quality code (or Technical Debt) can lead to a perception that efforts to improve quality may be ignored or undervalued, thus leading to further poor quality code.</description></item><item><title>The Dependency Inversion Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-dependency-inversion-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-dependency-inversion-principle/</guid><description>The Dependency Inversion Principle on Wikipedia
High-level modules should not be dependent on low-level implementations.
The fifth of the &amp;lsquo;SOLID&amp;rsquo; principles. This principle states that higher level orchestrating components should not have to know the details of their dependencies.
As an example, imagine we have a program which read metadata from a website. We would assume that the main component would have to know about a component to download the webpage content, then a component which can read the metadata.</description></item><item><title>The Dilbert Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-dilbert-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-dilbert-principle/</guid><description>The Dilbert Principle on Wikipedia
Companies tend to systematically promote incompetent employees to management to get them out of the workflow.
Scott Adams
A management concept developed by Scott Adams (creator of the Dilbert comic strip), the Dilbert Principle is inspired by The Peter Principle. Under the Dilbert Principle, employees who were never competent are promoted to management in order to limit the damage they can do. Adams first explained the principle in a 1995 Wall Street Journal article, and expanded upon it in his 1996 business book, The Dilbert Principle.</description></item><item><title>The DRY Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-dry-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-dry-principle/</guid><description>The DRY Principle on Wikipedia
Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
DRY is an acronym for Don&amp;rsquo;t Repeat Yourself. This principle aims to help developers reducing the repetition of code and keep the information in a single place and was cited in 1999 by Andrew Hunt and Dave Thomas in the book The Pragmatic Developer
The opposite of DRY would be WET (Write Everything Twice or We Enjoy Typing).</description></item><item><title>The Fallacies of Distributed Computing</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-fallacies-of-distributed-computing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-fallacies-of-distributed-computing/</guid><description>The Fallacies of Distributed Computing on Wikipedia
Also known as Fallacies of Networked Computing, the Fallacies are a list of conjectures (or beliefs) about distributed computing, which can lead to failures in software development. The assumptions are:
The network is reliable Latency is zero Bandwidth is infinite The network is secure Topology doesn&amp;rsquo;t change There is one administrator Transport cost is zero The network is homogeneous The first four items were listed by Bill Joy and Tom Lyon around 1991 and first classified by James Gosling as the &amp;ldquo;Fallacies of Networked Computing&amp;rdquo;.</description></item><item><title>The Hype Cycle &amp; Amara's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-hype-cycle-amaras-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-hype-cycle-amaras-law/</guid><description>The Hype Cycle on Wikipedia
We tend to overestimate the effect of a technology in the short run and underestimate the effect in the long run.
(Roy Amara)
The Hype Cycle is a visual representation of the excitement and development of technology over time, originally produced by Gartner. It is best shown with a visual:
(Image Reference: By Jeremykemp at English Wikipedia, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=10547051)
In short, this cycle suggests that there is typically a burst of excitement around new technology and its potential impact.</description></item><item><title>The Interface Segregation Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-interface-segregation-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-interface-segregation-principle/</guid><description>The Interface Segregation Principle on Wikipedia
No client should be forced to depend on methods it does not use.
The fourth of the &amp;lsquo;SOLID&amp;rsquo; principles. This principle states that consumers of a component should not depend on functions of that component which it doesn&amp;rsquo;t actually use.
As an example, imagine we have a method which reads an XML document from a structure which represents a file. It only needs to read bytes, move forwards or move backwards in the file.</description></item><item><title>The KISS principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-kiss-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-kiss-principle/</guid><description>KISS on Wikipedia
Keep it simple, stupid
The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. Originating in the U.S. Navy in 1960, the phrase has been associated with aircraft engineer Kelly Johnson.
The principle is best exemplified by the story of Johnson handing a team of design engineers a handful of tools, with the challenge that the jet aircraft they were designing must be repairable by an average mechanic in the field under combat conditions with only these tools.</description></item><item><title>The Law of Conservation of Complexity (Tesler's Law)</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-conservation-of-complexity-teslers-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-conservation-of-complexity-teslers-law/</guid><description>The Law of Conservation of Complexity on Wikipedia
This law states that there is a certain amount of complexity in a system which cannot be reduced.
Some complexity in a system is &amp;lsquo;inadvertent&amp;rsquo;. It is a consequence of poor structure, mistakes, or just bad modeling of a problem to solve. Inadvertent complexity can be reduced (or eliminated). However, some complexity is &amp;lsquo;intrinsic&amp;rsquo; as a consequence of the complexity inherent in the problem being solved.</description></item><item><title>The Law of Leaky Abstractions</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-leaky-abstractions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-leaky-abstractions/</guid><description>The Law of Leaky Abstractions on Joel on Software
All non-trivial abstractions, to some degree, are leaky.
(Joel Spolsky)
This law states that abstractions, which are generally used in computing to simplify working with complicated systems, will in certain situations &amp;lsquo;leak&amp;rsquo; elements of the underlying system, this making the abstraction behave in an unexpected way.
An example might be loading a file and reading its contents. The file system APIs are an abstraction of the lower level kernel systems, which are themselves an abstraction over the physical processes relating to changing data on a magnetic platter (or flash memory for an SSD).</description></item><item><title>The Law of Triviality</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-triviality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-law-of-triviality/</guid><description>The Law of Triviality on Wikipedia
This law suggests that groups will give far more time and attention to trivial or cosmetic issues rather than serious and substantial ones.
The common fictional example used is that of a committee approving plans for nuclear power plant, who spend the majority of their time discussing the structure of the bike shed, rather than the far more important design for the power plant itself.</description></item><item><title>The Liskov Substitution Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-liskov-substitution-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-liskov-substitution-principle/</guid><description>The Liskov Substitution Principle on Wikipedia
It should be possible to replace a type with a subtype, without breaking the system.
The third of the &amp;lsquo;SOLID&amp;rsquo; principles. This principle states that if a component relies on a type, then it should be able to use subtypes of that type, without the system failing or having to know the details of what that subtype is.
As an example, imagine we have a method which reads an XML document from a structure which represents a file.</description></item><item><title>The Open/Closed Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-openclosed-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-openclosed-principle/</guid><description>The Open/Closed Principle on Wikipedia
Entities should be open for extension and closed for modification.
The second of the &amp;lsquo;SOLID&amp;rsquo; principles. This principle states that entities (which could be classes, modules, functions and so on) should be able to have their behaviour extended, but that their existing behaviour should not be able to be modified.
As a hypothetical example, imagine a module which is able to turn a Markdown document into HTML.</description></item><item><title>The Pareto Principle (The 80/20 Rule)</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-pareto-principle-the-8020-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-pareto-principle-the-8020-rule/</guid><description>The Pareto Principle on Wikipedia
Most things in life are not distributed evenly.
The Pareto Principle suggests that in some cases, the majority of results come from a minority of inputs:
80% of a certain piece of software can be written in 20% of the total allocated time (conversely, the hardest 20% of the code takes 80% of the time) 20% of the effort produces 80% of the result 20% of the work creates 80% of the revenue 20% of the bugs cause 80% of the crashes 20% of the features cause 80% of the usage In the 1940s American-Romanian engineer Dr.</description></item><item><title>The Peter Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-peter-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-peter-principle/</guid><description>The Peter Principle on Wikipedia
People in a hierarchy tend to rise to their &amp;ldquo;level of incompetence&amp;rdquo;.
Laurence J. Peter
A management concept developed by Laurence J. Peter, the Peter Principle observes that people who are good at their jobs are promoted, until they reach a level where they are no longer successful (their &amp;ldquo;level of incompetence&amp;rdquo;. At this point, as they are more senior, they are less likely to be removed from the organisation (unless they perform spectacularly badly) and will continue to reside in a role which they have few intrinsic skills at, as their original skills which made them successful are not necessarily the skills required for their new jobs.</description></item><item><title>The Robustness Principle (Postel's Law)</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-robustness-principle-postels-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-robustness-principle-postels-law/</guid><description>The Robustness Principle on Wikipedia
Be conservative in what you do, be liberal in what you accept from others.
Often applied in server application development, this principle states that what you send to others should be as minimal and conformant as possible, but you should be aim to allow non-conformant input if it can be processed.
The goal of this principle is to build systems which are robust, as they can handle poorly formed input if the intent can still be understood.</description></item><item><title>The Single Responsibility Principle</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-single-responsibility-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-single-responsibility-principle/</guid><description>The Single Responsibility Principle on Wikipedia
Every module or class should have a single responsibility only.
The first of the &amp;lsquo;SOLID&amp;rsquo; principles. This principle suggests that modules or classes should do one thing and one thing only. In more practical terms, this means that a single, small change to a feature of a program should require a change in one component only. For example, changing how a password is validated for complexity should require a change in only one part of the program.</description></item><item><title>The Spotify Model</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-spotify-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-spotify-model/</guid><description>The Spotify Model on Spotify Labs
The Spotify Model is an approach to team and organisation structure which has been popularised by &amp;lsquo;Spotify&amp;rsquo;. In this model, teams are organised around features, rather than technologies.
The Spotify Model also popularises the concepts of Tribes, Guilds, Chapters, which are other components of their organisation structure.</description></item><item><title>The Unix Philosophy</title><link>https://1t1e1.github.io/hacker-laws-web/law/the-unix-philosophy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/the-unix-philosophy/</guid><description>The Unix Philosophy on Wikipedia
The Unix Philosophy is that software components should be small, and focused on doing one specific thing well. This can make it easier to build systems by composing together small, simple, well-defined units, rather than using large, complex, multi-purpose programs.
Modern practices like &amp;lsquo;Microservice Architecture&amp;rsquo; can be thought of as an application of this law, where services are small, focused and do one specific thing, allowing complex behaviour to be composed of simple building blocks.</description></item><item><title>Wadler's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/wadlers-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/wadlers-law/</guid><description>Wadler&amp;rsquo;s Law on wiki.haskell.org
In any language design, the total time spent discussing a feature in this list is proportional to two raised to the power of its position.
Semantics Syntax Lexical syntax Lexical syntax of comments (In short, for every hour spent on semantics, 8 hours will be spent on the syntax of comments).
Similar to The Law of Triviality, Wadler&amp;rsquo;s Law states what when designing a language, the amount of time spent on language structures is disproportionately high in comparison to the importance of those features.</description></item><item><title>Wheaton's Law</title><link>https://1t1e1.github.io/hacker-laws-web/law/wheatons-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/wheatons-law/</guid><description>The Link
The Official Day
Don&amp;rsquo;t be a dick.
Wil Wheaton
Coined by Wil Wheaton (Star Trek: The Next Generation, The Big Bang Theory), this simple, concise, and powerful law aims for an increase in harmony and respect within a professional organization. It can be applied when speaking with coworkers, performing code reviews, countering other points of view, critiquing, and in general, most professional interactions humans have with each other.</description></item><item><title>YAGNI</title><link>https://1t1e1.github.io/hacker-laws-web/law/yagni/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1t1e1.github.io/hacker-laws-web/law/yagni/</guid><description>YAGNI on Wikipedia
This is an acronym for You Ain&amp;rsquo;t Gonna Need It.
Always implement things when you actually need them, never when you just foresee that you need them.
(Ron Jeffries) (XP co-founder and author of the book &amp;ldquo;Extreme Programming Installed&amp;rdquo;)
This Extreme Programming (XP) principle suggests developers should only implement functionality that is needed for the immediate requirements, and avoid attempts to predict the future by implementing functionality that might be needed later.</description></item></channel></rss>